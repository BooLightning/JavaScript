<!DOCTYPE html>
<!--
/**
 * Hi guys
 * 
 * Prompt: Make a game where you dodge falling objects while trying to jump across platforms to reach a portal that transports you to the next level. It combines aspects of dodge games and platformers to create a revolutionary new idea! 
 *
 * Ok
 */
-->

<html>

<head>
  <meta charset="utf-8">
  <title>Multiplayer Platformer</title>
  <!--p5.js source-->
  <script rel="proconnect" src="https://cdn.jsdelivr.net/gh/NovaSagittarii/misc@1.0.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.0/simplepeer.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/kqwq/zeta4/library/meta-slim-client.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    #in {
      position: absolute;
      right: 0;
      padding: 10px;
      width: calc(100vw - 100vh - 20px);
    }
  </style>
</head>

<body>
<script></script>
  <canvas id="defaultCanvas0"></canvas>

  <div id="in">
    <h4>Multiplayer Platformer</h4>
    <label for="in-t">Name</label>
    <input id="in-t" type="text" onchange="updateText(this.value)">
    <br>
    <br>
    <label for="in-c">Color</label><br>
    <input id="in-c" type="color" onchange="updateColor(this.value)">
    <br>
    <br>
    <i id="status">Loading...</i>
    <button onclick="leave()">Leave</button>

  </div>
  <script type>
    {
let CONST = {
  gravity: 0.01,
  gridBlocks: 20,

}
var gb = CONST.gridBlocks
var gs
gs = CONST.gs = CONST.gridSize = Math.min(window.innerWidth, window.innerHeight) / CONST.gridBlocks;
class Game {
  constructor() {
    this.objs = []

    this.cols = [
      [33],
      [200, 255, 250],
      [255, 255, 0],
      [255, 0, 255],
    ]
    this.level = [...Array(gb)].map(() => new Array(gb).fill(0))
    for (let i = 0; i < this.level.length; i++) {
      var row = this.level[i]
      for (let j = 0; j < this.level.length; j++) {
        var cell = row[j]
        if (Math.tan(i * j) + Math.sin(j * Math.PI) > 1 - i / 40) {
          this.level[i][j] = 1
        }
      }
    }

  }

  create(obj) {
    this.objs.push(obj)
  }

  mainLoop() {

    // draw blocks

    stroke(0)
    strokeWeight(3)

    for (let i = 0; i < this.level.length; i++) {
      var row = this.level[i]
      for (let j = 0; j < this.level.length; j++) {
        var cell = row[j]
        if (cell > 0) {
          var c = this.cols[cell]
          fill(...c)
          rect(j * gs, i * gs, gs, gs, 5);
        }
      }
    }

    // draw
    for (let i = this.objs.length - 1; i >= 0; i--) {
      this.objs[i]?.draw()
    }

    // update
    for (let i = this.objs.length - 1; i >= 0; i--) {
      var obj = this.objs[i]
      obj?.update()
      if (obj?.hp <= 0) {
        this.objs.splice(i, 1)
      }
      // prevent entities from going off-screen
      obj.x = constrain(obj.x, -0.3, gb - 0.7)
      obj.y = constrain(obj.y, -0.3, gb - 0.7)
      if (obj.y > gb - 1) {
        obj?.hurt()
      }
    }
  }
}
var game = new Game();

var me

class Player {
  constructor(x, y, name) {
    game.create(this);
    this.game = game;
    this.name = name;
    this.hp = 10;
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.speed = 0.0921;
    this.jumpSpeed = 0.3
    this.falling = !false
    this.col = [255, 0, 0] || color;
  }
  onKey(keyCode) {
    if (keyCode === 65) {
      this.vx = -this.speed;
    } else if (keyCode === 68) {
      this.vx = this.speed;
    }
    if (keyCode === 87) {
      if (this.falling) return
      this.vy = -this.jumpSpeed;
      this.falling = true
    } else if (keyCode === 83) {
      this.vx = 0
    }

  }

  offKey(keyCode) {
    if (keyCode === 65) {
      this.vx = 0
    } else if (keyCode === 68) {
      this.vx = 0
    }
  }

  hurt() {
    this.y -= 20
  }

  handleCollision(bx, by) {
    //player above block
    let blockBelow = by - this.y > abs(bx - this.x)
    if (blockBelow) {
      this.falling = false
      this.y = Math.min(by - 1, this.y)
    }
    //player below block
    else if (-by + this.y > abs(bx - this.x)) {
      this.vy = 0
      this.y = Math.max(by + 1, this.y)
    }
    //left
    else if (bx - this.x > abs(by - this.y)) {
      this.x = Math.min(bx - 1, this.x)
    }
    //right
    else if (-bx + this.x > abs(by - this.y)) {
      this.x = Math.max(bx + 1, this.x)
    }

  }

  update() {
    this.x += this.vx;
    if (this.falling) {
      this.y += this.vy;
      this.vy += CONST.gravity;
    }

    // get 4 potential collision blocks
    let lev = this.game.level
    var x0 = constrain(Math.floor(this.x), 0, gb - 1)
    var x1 = constrain(Math.ceil(this.x), 0, gb - 1)
    var y0 = constrain(Math.floor(this.y), 0, gb - 1)
    var y1 = constrain(Math.ceil(this.y), 0, gb - 1)
    var xBelow = constrain(Math.round(this.x), 0, gb - 1)
    var yBelow = constrain(Math.round(this.y) + 1, 0, gb - 1)
    let pos_s = [
      [y0, x0]
    ]
    if (x0 !== x1) {
      pos_s.push([y0, x1])
      if (y0 !== y1) {
        pos_s.push([y1, x0])
        pos_s.push([y1, x1])
      }
    } else {
      if (y0 !== y1) {
        pos_s.push([y1, x0])
      }
    }
    for (let pos of pos_s) {
      let x = pos[1]
      let y = pos[0]
      let cell = lev[y][x]
      if (cell > 0) {
        this.handleCollision(x, y);
      }
    }

    // check if falling
    if (this.vx !== 0) {
      if (lev[yBelow][xBelow] === 0) {
        this.falling = true
      }
    }
  }

  draw() {
    strokeWeight(2);
    stroke(0)
    fill(...this.col)
    rect(this.x * gs, this.y * gs, gs, gs);
    stroke(255)
    fill(0)
    textAlign(CENTER, CENTER)
    text(this.name, this.x * gs + gs * 0.5, this.y * gs - gs * 0.5)
  }
}


function setup() {
  createCanvas(400, 400);
  me = new Player(5, 1, 'me');
}

function draw() {
  background(220);
  game.mainLoop()

}

function keyPressed() {
  me.onKey(keyCode)
}
function keyReleased() {
  me.offKey(keyCode)
}

function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16)
  ] : [0];
}

function updateText(t) {
  send("!change-guest-uid " + t)
}
function updateColor(c) {
  me.col = hexToRgb(c)
}

var isConnected = false
var client

function onRecieve(data) {
  if (data.startsWith("^")) {
    let json = JSON.parse(data.substring(1))
    let {
      sender,
      message
    } = json
    if (sender === me.name) return // ignore own messages
    if (sender === "server") {
      let {
        command,
        response
      } = JSON.parse(message)
      if (command === "player-join") {
        if (response === me.name) return
        new Player(2, 2, response)
      } else if (command === "player-leave") {
        game.objs = game.objs.filter(p => p.name !== response)
      }
    } else {
      let player = game.objs.find(p => p.name === sender)
      if (!player) {
        console.log(`Player ${sender} not found locally, creating new player`)
        player = new Player(2, 2, sender)
      }
      let d = message.split(" ")
      player.x = parseFloat(d[1])
      player.y = parseFloat(d[2])
      player.vx = parseFloat(d[3])
      player.vy = parseFloat(d[4])
      player.falling = Boolean(parseInt(d[5]))
      player.col[0] = parseInt(d[6])
      player.col[1] = parseInt(d[7])
      player.col[2] = parseInt(d[8])
    }

  } else {
    let [firstArg, secondArg] = data.split(/ (.+)/s)
    if (firstArg === 'set-uid') {
      me.name = secondArg
    }
  }
}

function send(data) {
  client.send(data)
}

function leave() {
  client.send("!leave-game")
  $(`#status`).text("Disconnected")
}

function onStatus(status) {
  $(`#status`).text(status)
}

function onConnect() {
  $(`#status`).text(`Connected`)
  isConnected = true
  setTimeout(() => {
    send('!get-guest-uid') // get guest uid
  }, 1000)
  setTimeout(() => {
    send("!join-game broadcast") // join the broadcast game
  }, 2000)
}

async function connect() {
  client = new MetaverseClient(onStatus, onConnect, onRecieve)
  client.connectToServer()
}
connect()

var ticksPerSecond = 5
setInterval(() => {
  if (isConnected) {
    send(`^move ${me.x.toFixed(3)} ${me.y.toFixed(3)} ${me.vx.toFixed(4)} ${me.vy.toFixed(4)} ${me.falling ? 1 : 0} ${me.col[0]} ${me.col[1]} ${me.col[2]}`)
  }
}, 1000 / ticksPerSecond)

// Every 5 seconds, empty the objs array
setInterval(() => {
  game.objs = [me]
}, 5000)

    }
  </script>
</body>

</html>